import ghidra.app.decompiler.ClangFieldToken;
import ghidra.app.decompiler.ClangLine;
import ghidra.app.decompiler.ClangToken;
import ghidra.app.decompiler.ClangTokenGroup;
import ghidra.app.decompiler.DecompInterface;
import ghidra.app.decompiler.DecompileOptions;
import ghidra.app.decompiler.DecompileResults;
import ghidra.app.decompiler.component.DecompilerUtils;
import ghidra.app.decompiler.parallel.DecompileConfigurer;
import ghidra.app.decompiler.parallel.DecompilerCallback;
import ghidra.app.decompiler.parallel.ParallelDecompiler;
import ghidra.app.extension.datatype.finder.DecompilerVariable;
import ghidra.app.extension.datatype.finder.DecompilerReference;
import ghidra.app.script.GhidraScript;
import ghidra.program.model.address.Address;
import ghidra.program.model.block.BasicBlockModel;
import ghidra.program.model.block.CodeBlock;
import ghidra.program.model.data.DataType;
import ghidra.program.model.data.DataTypeComponent;
import ghidra.program.model.data.DefaultDataType;
import ghidra.program.model.data.Structure;
import ghidra.program.model.data.StructureDataType;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Listing;
import ghidra.program.model.listing.Program;
import ghidra.util.Msg;
import ghidra.util.task.TaskMonitor;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Analyzes cache misses to suggest reorderings of struct fields.
 */
public class StructOrderAnalysis extends GhidraScript {
	@Override
	public void run() throws Exception {
		// Read address_info.csv to find relevant addresses
		Path csv = Paths.get(getScriptArgs()[0]);
		BcpiData data = BcpiData.parse(csv, this.currentProgram);

		// Get the decompilation of each function containing an address
		// for which we have data.  This is much faster than calling
		// DataTypeReferenceFinder once per field.
		Set<Function> functions = data.getRelevantFunctions();
		FieldReferences refs = FieldReferences.collect(this.currentProgram, functions, this.monitor);

		// Use our collected data to infer field access patterns
		AccessPatterns patterns = AccessPatterns.collect(this.currentProgram, data, refs, this.monitor);

		// Try to optimize struct layouts
		for (Structure struct : patterns.getStructures()) {
			Structure optimized = patterns.optimize(struct);
			prettyPrint(optimized);
		}
	}

	private void prettyPrint(Structure struct) {
		System.out.format("struct %s {\n", struct.getName());
		for (DataTypeComponent field : struct.getComponents()) {
			// Skip padding
			if (!field.getDataType().equals(DefaultDataType.dataType)) {
				System.out.format("\t%s %s;\n", field.getDataType().getName(), field.getFieldName());
			}
		}
		System.out.format("};\n\n");
	}
}

/**
 * Holds the data collected by BCPI.
 */
class BcpiData {
	private final Map<Address, Integer> data;
	private final Program program;

	private BcpiData(Map<Address, Integer> data, Program program) {
		this.data = data;
		this.program = program;
	}

	/**
	 * Parse a CSV file generated by bcpiutil.
	 */
	static BcpiData parse(Path csv, Program program) throws IOException {
		Map<Address, Integer> data = new HashMap<>();

		try (BufferedReader reader = Files.newBufferedReader(csv)) {
			String line = null;
			while ((line = reader.readLine()) != null) {
				String values[] = line.split(",");
				int count = Integer.parseInt(values[0]);
				Address[] addresses = program.parseAddress(values[1]);
				for (Address address : addresses) {
					data.merge(address, count, (prev, cur) -> prev + cur);
				}
			}
		}

		return new BcpiData(data, program);
	}

	/**
	 * @return All the functions that contain an address for which we have data.
	 */
	Set<Function> getRelevantFunctions() {
		Set<Function> functions = new HashSet<>();

		Listing listing = this.program.getListing();
		for (Address address : this.data.keySet()) {
			Function func = listing.getFunctionContaining(address);
			if (func != null) {
				functions.add(func);
			}
		}

		return functions;
	}

	/**
	 * @return All addresses for which we have data.
	 */
	Set<Address> getAddresses() {
		return this.data.keySet();
	}

	/**
	 * @return The number of events collected for the given address.
	 */
	int getCount(Address address) {
		return this.data.getOrDefault(address, 0);
	}
}

/**
 * Maps code addresses to the struct field(s) they reference.
 */
class FieldReferences {
	private final Map<Address, Set<DataTypeComponent>> refs = new ConcurrentHashMap<>();
	private final AtomicInteger decompileCount = new AtomicInteger();
	private final Program program;
	private final Set<Function> functions;

	private FieldReferences(Program program, Set<Function> functions) {
		this.program = program;
		this.functions = functions;
	}

	/**
	 * Collect the struct field references in the specified functions.
	 */
	static FieldReferences collect(Program program, Set<Function> functions, TaskMonitor monitor) throws Exception {
		FieldReferences refs = new FieldReferences(program, functions);
		refs.collect(monitor);
		return refs;
	}

	private void collect(TaskMonitor monitor) throws Exception {
		QCallback callback = new QCallback();
		try {
			ParallelDecompiler.decompileFunctions(callback, functions, monitor);
		} finally {
			callback.dispose();
		}

		Msg.info(this, "Decompiled " + this.decompileCount.intValue() + " functions");

		int refCount = 0;
                for (Map.Entry<Address, Set<DataTypeComponent>> entry : this.refs.entrySet()) {
                    refCount += entry.getValue().size();
		}
		Msg.info(this, "Found " + refCount + " field references");
	}

	/**
	 * Get the fields accessed at a particular address.
	 */
	Set<DataTypeComponent> getFields(Address address) {
		return this.refs.getOrDefault(address, Collections.emptySet());
	}

	/**
	 * Based on Ghidra's DecompilerDataTypeReferenceFinder.
	 */
	private class QCallback extends DecompilerCallback<Void> {
		QCallback() {
			super(program, new DecompilerConfigurer());
		}

		@Override
		public Void process(DecompileResults results, TaskMonitor monitor) {
			processDecompilation(results);
			return null;
		}
	}

	private static class DecompilerConfigurer implements DecompileConfigurer {
		@Override
		public void configure(DecompInterface decompiler) {
			decompiler.toggleCCode(true);
			decompiler.toggleSyntaxTree(true);
			decompiler.setSimplificationStyle("decompile");

			DecompileOptions xmlOptions = new DecompileOptions();
			xmlOptions.setDefaultTimeout(60);
			decompiler.setOptions(xmlOptions);
		}
	}

	/**
	 * Process a single decompiled function.
	 */
	void processDecompilation(DecompileResults results) {
		int count = this.decompileCount.incrementAndGet();
		if (count % 1000 == 0) {
			Msg.info(this, "Decompiled " + count + " functions");
		}

		Function function = results.getFunction();
		if (function.isThunk()) {
			return;
		}

		ClangTokenGroup tokens = results.getCCodeMarkup();
		if (tokens == null) {
			Msg.warn(this, "Failed to decompile " + function.getName());
			return;
		}

		for (ClangLine line : DecompilerUtils.toLines(tokens)) {
			processLine(line);
		}
	}

	/**
	 * Process a single line of a decompiled function.
	 */
	private void processLine(ClangLine line) {
		for (ClangToken token : line.getAllTokens()) {
			if (token instanceof ClangFieldToken) {
				processField((ClangFieldToken) token);
			}
		}
	}

	/**
	 * Process a field access.
	 */
	private void processField(ClangFieldToken token) {
		DataTypeComponent field = getField(token);
		if (field == null || ignoreDataType(field.getParent())) {
			return;
		}

		Address address = getAddress(token);
		this.refs.computeIfAbsent(address, a -> ConcurrentHashMap.newKeySet())
			.add(field);
	}

	/**
	 * Finds the field associated with a ClangFieldToken.
	 */
	private DataTypeComponent getField(ClangFieldToken token) {
		DataType baseType = DecompilerReference.getBaseType(token.getDataType());

		if (baseType instanceof Structure) {
			Structure parent = (Structure) baseType;
			int offset = token.getOffset();
			if (offset >= 0 && offset < parent.getLength()) {
				return parent.getComponentAt(offset);
			}
		}

		return null;
	}

	/**
	 * Finds the address of a field access.
	 */
	private Address getAddress(ClangFieldToken token) {
		// Access DecompilerVariable's protected constructor through an
		// anonymous subclass
		return (new DecompilerVariable(token) {}).getAddress();
	}

	/**
	 * Check if a struct should be processed.  We are looking for non-system
	 * DWARF types.
	 */
	private boolean ignoreDataType(DataType type) {
		String name = type.getPathName();

		if (!name.startsWith("/DWARF/")) {
			return true;
		}

		if (name.contains("/std/")
		    || name.contains("/stdlib.h/")
		    || name.contains("/stdio.h/")
		    || name.contains("/_UNCATEGORIZED_/")) {
			return true;
		}

		return false;
	}
}

/**
 * Struct field access patterns.
 */
class AccessPatterns {
	private final Map<DataTypeComponent, Integer> counts = new HashMap<>();

	/**
	 * Infer access patterns from the collected data.
	 */
	static AccessPatterns collect(Program program, BcpiData data, FieldReferences refs, TaskMonitor monitor) throws Exception {
		AccessPatterns patterns = new AccessPatterns();
		BasicBlockModel bbModel = new BasicBlockModel(program);

		for (Address baseAddress : data.getAddresses()) {
			int count = data.getCount(baseAddress);
			if (count == 0) {
				continue;
			}

			for (CodeBlock block : bbModel.getCodeBlocksContaining(baseAddress, monitor)) {
				for (Address address : block.getAddresses(true)) {
					for (DataTypeComponent field : refs.getFields(address)) {
						patterns.counts.merge(field, count, (prev, cur) -> prev + cur);
					}
				}
			}
		}

		for (Map.Entry<DataTypeComponent, Integer> count : patterns.counts.entrySet()) {
			DataTypeComponent field = count.getKey();
			System.out.format("%s::%s : %d\n", field.getParent().getName(), field.getFieldName(), count.getValue());
		}

		return patterns;
	}

	/**
	 * @return All the structures about which we have data.
	 */
	Set<Structure> getStructures() {
		Set<Structure> structs = new HashSet<>();
		for (DataTypeComponent field : this.counts.keySet()) {
			structs.add((Structure) field.getParent());
		}
		return structs;
	}

	/**
	 * Optimize the layout of a struct according to its access pattern.
	 */
	Structure optimize(Structure struct) {
		List<DataTypeComponent> fields = new ArrayList<>();
		for (DataTypeComponent field : struct.getComponents()) {
			// Skip padding
			if (!field.getDataType().equals(DefaultDataType.dataType)) {
				fields.add(field);
			}
		}

		Collections.sort(fields, Comparator
			.comparingInt(f -> counts.getOrDefault(f, 0))
			.reversed());

		// Sort the fields by our estimated cost
		StructureDataType optimized = new StructureDataType(struct.getCategoryPath(), struct.getName(), 0);
		for (DataTypeComponent field : fields) {
			optimized.add(field.getDataType(), field.getLength(), field.getFieldName(), field.getComment());
		}
		return optimized;
	}
}

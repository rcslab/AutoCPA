package bcpi;

import bcpi.BcpiConfig;
import bcpi.BcpiDataRow;

import ghidra.program.model.address.Address;
import ghidra.program.model.listing.Function;
import ghidra.program.model.listing.Program;
import ghidra.util.task.TaskMonitor;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.SetMultimap;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Holds the data collected by BCPI.
 */
public class BcpiData {
	private final Map<Address, BcpiDataRow> rows;

	private BcpiData(Map<Address, BcpiDataRow> rows) {
		this.rows = ImmutableMap.copyOf(rows);
	}

	/**
	 * Parse a CSV file generated by bcpiutil.
	 */
	public static BcpiData parse(Path csv, List<Program> programs) throws IOException {
		Map<Address, BcpiDataRow> rows = new HashMap<>();

		try (BufferedReader reader = Files.newBufferedReader(csv)) {
			String line = null;
			while ((line = reader.readLine()) != null) {
				String values[] = line.split(",");
				String kv[] = values[1].split("=");
				int count = Integer.parseInt(kv[1]);

				for (Program program : programs) {
					Address address = program.getAddressFactory().getAddress(values[0]);
					if (address == null) {
						continue;
					}

					Function function = program.getListing().getFunctionContaining(address);
					if (function != null) {
						rows.put(address, new BcpiDataRow(address, program, function, count));
						break;
					}
				}
			}
		}

		return new BcpiData(rows);
	}

	/**
	 * @return All the functions that contain an address for which we have data.
	 */
	public SetMultimap<Program, Function> getRelevantFunctions(Collection<Program> programs, TaskMonitor monitor) {
		SetMultimap<Program, Function> funcs = HashMultimap.create();
		for (BcpiDataRow row : this.rows.values()) {
			if (programs.contains(row.program)) {
				addFunction(funcs, row.function, 0, monitor);
			}
		}
		return funcs;
	}

	private void addFunction(SetMultimap<Program, Function> funcs, Function func, int depth, TaskMonitor monitor) {
		if (funcs.put(func.getProgram(), func) && depth < BcpiConfig.IPA_DEPTH) {
			for (Function callee : func.getCalledFunctions(monitor)) {
				addFunction(funcs, callee, depth + 1, monitor);
			}
		}
	}

	/**
	 * @return All addresses for which we have data.
	 */
	public Set<Address> getAddresses() {
		return this.rows.keySet();
	}

	/**
	 * @return The number of events collected for the given address.
	 */
	public int getCount(Address address) {
		BcpiDataRow row = this.rows.get(address);
		if (row == null) {
			return 0;
		} else {
			return row.count;
		}
	}

	/**
	 * @return The row associated with the given address, or null.
	 */
	public BcpiDataRow getRow(Address address) {
		return this.rows.get(address);
	}
}
